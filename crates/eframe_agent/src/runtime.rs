use std::{
    fmt,
    sync::{
        Arc,
        atomic::{AtomicBool, Ordering},
        mpsc,
    },
    thread,
    time::Duration,
};

use parking_lot::Mutex;
use serde::{Deserialize, Serialize};

/// Commands that can be sent to an [`AgentRuntime`].
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum AgentCommand {
    /// Submit free-form text to the agent.
    SubmitPrompt(String),

    /// Cancel the currently running task, if any.
    CancelActiveTask,

    /// Clears message history.
    ClearHistory,

    #[doc(hidden)]
    Shutdown,
}

/// Role associated with an [`AgentUpdate::Message`].
#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum MessageRole {
    /// Text originating from a human.
    User,

    /// Text generated by the automated agent.
    Agent,

    /// System level notices like task transitions.
    System,
}

/// Control actions emitted by the agent runtime.
#[derive(Clone, Copy, Debug, Serialize, Deserialize, PartialEq, Eq)]
pub enum ControlAction {
    /// Request the host window to close.
    CloseWindow,
}

/// Updates emitted by an [`AgentRuntime`].
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
pub enum AgentUpdate {
    /// Represents a message appended to the conversation.
    Message {
        /// Who authored the message.
        role: MessageRole,

        /// Message text body.
        text: String,
    },

    /// Signals that a task began executing.
    TaskStarted {
        /// Task identifier.
        id: u64,

        /// Short label describing the task.
        label: String,
    },

    /// Signals that a task completed.
    TaskFinished {
        /// Task identifier.
        id: u64,

        /// Short label describing the task.
        label: String,

        /// Whether the task completed successfully.
        success: bool,
    },

    /// Clears local message/task state.
    Reset,

    /// Append a line to the UI tool log.
    UiLog {
        /// Log text entry.
        text: String,
    },

    /// Control action to be handled by the host app.
    Control {
        /// Control instruction emitted by the runtime.
        action: ControlAction,
    },
}

/// Wire envelope for transporting commands/updates over IPC or network bridges.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq)]
#[serde(tag = "kind", rename_all = "snake_case")]
pub enum AgentEnvelope {
    /// Command issued by the UI.
    Command {
        /// Command payload sent to the backend.
        command: AgentCommand,
    },

    /// Update emitted by the runtime/agent.
    Update {
        /// Update payload sent back to the UI.
        update: AgentUpdate,
    },
}

impl AgentUpdate {
    /// Convenience helper for building user messages.
    pub fn user<T: Into<String>>(text: T) -> Self {
        Self::Message {
            role: MessageRole::User,
            text: text.into(),
        }
    }

    /// Convenience helper for agent messages.
    pub fn agent<T: Into<String>>(text: T) -> Self {
        Self::Message {
            role: MessageRole::Agent,
            text: text.into(),
        }
    }

    /// Convenience helper for tool/UI log entries.
    pub fn ui_log<T: Into<String>>(text: T) -> Self {
        Self::UiLog { text: text.into() }
    }
}

/// Runtime trait used by [`crate::AgentApp`].
///
/// Implementations are responsible for executing long running actions away from the UI thread
/// and producing [`AgentUpdate`] events that drive the UI.
pub trait AgentRuntime: Send + Sync + 'static {
    /// Submit a [`AgentCommand`] for execution.
    fn submit_command(&self, command: AgentCommand);

    /// Drain pending updates into `out`.
    fn poll_updates(&self, out: &mut Vec<AgentUpdate>);

    /// Request the runtime to shut down.
    fn shutdown(&self);
}

impl fmt::Debug for dyn AgentRuntime {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "AgentRuntime(..)")
    }
}

/// Simple channel/worker thread based runtime useful for demos and tests.
#[derive(Clone)]
pub struct SimpleAgentRuntime {
    command_tx: mpsc::Sender<AgentCommand>,
    update_rx: Arc<Mutex<mpsc::Receiver<AgentUpdate>>>,
    is_running: Arc<AtomicBool>,
    worker: Arc<Mutex<Option<thread::JoinHandle<()>>>>,
}

impl SimpleAgentRuntime {
    /// Create a new runtime.
    pub fn new() -> Self {
        let (command_tx, command_rx) = mpsc::channel();
        let (update_tx, update_rx) = mpsc::channel();
        let running = Arc::new(AtomicBool::new(true));
        let worker_running = running.clone();

        let worker = thread::Builder::new()
            .name("eframe_agent_simple_runtime".to_string())
            .spawn(move || {
                let mut next_task_id = 1_u64;

                while worker_running.load(Ordering::Relaxed) {
                    match command_rx.recv_timeout(Duration::from_millis(50)) {
                        Ok(AgentCommand::SubmitPrompt(prompt)) => {
                            let label = format!("handle-prompt-{next_task_id}");
                            let task_id = next_task_id;
                            next_task_id += 1;

                            let _ = update_tx.send(AgentUpdate::user(prompt.clone()));
                            let _ = update_tx.send(AgentUpdate::TaskStarted {
                                id: task_id,
                                label: label.clone(),
                            });

                            // Pretend work happened.
                            let reply = format!("Echo: {prompt}");
                            let _ = update_tx.send(AgentUpdate::agent(reply));
                            let _ = update_tx.send(AgentUpdate::TaskFinished {
                                id: task_id,
                                label,
                                success: true,
                            });
                        }
                        Ok(AgentCommand::CancelActiveTask) => {
                            let _ = update_tx.send(AgentUpdate::Message {
                                role: MessageRole::System,
                                text: "Cancel requested (demo runtime has no active task).".into(),
                            });
                        }
                        Ok(AgentCommand::ClearHistory) => {
                            let _ = update_tx.send(AgentUpdate::Reset);
                        }
                        Ok(AgentCommand::Shutdown) => {
                            break;
                        }
                        Err(mpsc::RecvTimeoutError::Disconnected) => break,
                        Err(mpsc::RecvTimeoutError::Timeout) => continue,
                    }
                }
            })
            .expect("failed to spawn simple agent runtime thread");

        Self {
            command_tx,
            update_rx: Arc::new(Mutex::new(update_rx)),
            is_running: running,
            worker: Arc::new(Mutex::new(Some(worker))),
        }
    }
}

impl Default for SimpleAgentRuntime {
    fn default() -> Self {
        Self::new()
    }
}

impl AgentRuntime for SimpleAgentRuntime {
    fn submit_command(&self, command: AgentCommand) {
        let _ = self.command_tx.send(command);
    }

    fn poll_updates(&self, out: &mut Vec<AgentUpdate>) {
        let receiver = self.update_rx.lock();
        while let Ok(update) = receiver.try_recv() {
            out.push(update);
        }
    }

    fn shutdown(&self) {
        if self
            .is_running
            .compare_exchange(true, false, Ordering::SeqCst, Ordering::SeqCst)
            .is_ok()
        {
            let _ = self.command_tx.send(AgentCommand::Shutdown);
            if let Some(handle) = self.worker.lock().take() {
                handle.join().ok();
            }
        }
    }
}

impl Drop for SimpleAgentRuntime {
    fn drop(&mut self) {
        self.shutdown();
    }
}
